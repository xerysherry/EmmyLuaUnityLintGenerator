using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;

#if UNITY_EDITOR
using UnityEditor;
#endif

public static partial class LintGenerator
{
#if UNITY_EDITOR
    [MenuItem("Tools/GenerateUnityLint")]
#endif
    public static void Generate()
    {
        existedSet.Clear();
        namespaceSet.Clear();
        typeDefines.Clear();
        namespaceDefine.Clear();
        fileDefines.Clear();

        foreach (var assemblyString in AssemblyList)
        {
            var assembly = Assembly.Load(assemblyString);
            Generate(assembly);
        }
        foreach (var assemblyString in AssemblyFile)
        {
            var assembly = Assembly.LoadFile(assemblyString);
            Generate(assembly);
        }

        ClearXML();
        if (TypeXmlPath != null && TypeXmlPath.Length > 0)
        {
            foreach (var path in TypeXmlPath)
            {
                if(File.Exists(path))
                    PrepareXML(path);
            }
        }
        foreach (var t in TypeList)
        {
            Create(t);
        }
        Save();
    }

    static void Generate(Assembly assembly)
    {
        ClearXML();
        LoadAssemblXml(assembly);

        Console.WriteLine("Processing..." + assembly.FullName);
        if (!CheckRefAssembly(assembly))
        {
            return;
        }

        foreach (var type in assembly.GetExportedTypes())
        {
            if (skipType.Contains(type))
                continue;
            Create(type);
        }
    }

    static bool CheckRefAssembly(Assembly assembly)
    {
        var list = assembly.GetReferencedAssemblies();
        var result = true;
        foreach (var name in list)
        {
            try
            {
                var refAsm = Assembly.Load(name);
                if(refAsm != null)
                    LoadAssemblXml(refAsm);
            }
            catch (FileNotFoundException _)
            {
                Console.WriteLine("NotFound Assembly: " + name);
                result = false;
            }
        }
        return result;
    }

    static void LoadAssemblXml(Assembly assembly)
    {
        var dllfilepath = assembly.ManifestModule.FullyQualifiedName;
        var xmlfilepath =
            Path.GetDirectoryName(dllfilepath) + "\\" +
            Path.GetFileNameWithoutExtension(dllfilepath) + ".xml";
        if (File.Exists(xmlfilepath))
            PrepareXML(xmlfilepath);
    }

    static void Save()
    {
        var filedir = Folder;
        if (!string.IsNullOrEmpty(filedir))
        {
            if (!Directory.Exists(filedir))
            {
                Directory.CreateDirectory(filedir);
            }
            filedir = filedir + "\\";
        }
        else
        {
            filedir = "";
        }

        if (AllInOne)
        {
            typeDefines.Add("--- Generated By xerysherry");
            File.WriteAllLines(filedir + AllInOneFilename, typeDefines);
        }
        else
        {
            var script = namespaceDefine.ToString();
            if (!string.IsNullOrEmpty(script))
                File.WriteAllText(filedir + "(-_-b).lua", script);
            foreach (var item in fileDefines)
            {
                if (string.IsNullOrEmpty(item.Value))
                    continue;
                script = item.Value;
                script = script + "---  Generated By xerysherry";
                File.WriteAllText(filedir + item.Key + ".lua", script);
            }
        }
    }

    static void Create(Type type)
    {
        if (existedSet.Contains(type))
            return;

        if (type.IsEnum)
        {
            CreateEnum(type);
        }
        else if (type.IsClass || type.IsValueType)
        {
            CreateClass(type);
        }
        else
        {

        }
        existedSet.Add(type);
    }

    static HashSet<MethodInfo> GetPropertyGetSetMethod(bool isStatic, Type type)
    {
        var set = new HashSet<MethodInfo>();
        var members = type.GetMembers(
                (isStatic ? BindingFlags.Static : BindingFlags.Instance) | BindingFlags.Public);
        foreach (var m in members)
        {
            if (m.MemberType == MemberTypes.Property)
            {
                var pi = (PropertyInfo)m;
                var getMethod = pi.GetGetMethod(false);
                if (getMethod != null)
                    set.Add(getMethod);
                var setMethod = pi.GetGetMethod(false);
                if (setMethod != null)
                    set.Add(setMethod);
            }
        }
        return set;
    }

    static List<(string, string, string, Descriptor)> GetPropertyAndField(
        bool isStatic, string classname, Type type)
    {
        var pf = new List<(string, string, string, Descriptor)>();
        var pm = new HashSet<string>();

        //静态方法，属性，变量
        var members = type.GetMembers(
            (isStatic ? BindingFlags.Static : BindingFlags.Instance) | BindingFlags.Public);
        foreach (var m in members)
        {
            if (m.MemberType == MemberTypes.Property)
            {
                var pi = (PropertyInfo)m;
                var fdesc = GetFirstDescriptor(classname + "." + m.Name);
                var pdesc = "property ";
                if (pi.GetGetMethod(false) != null)
                    pdesc = pdesc + "get";
                if (pi.GetSetMethod(false) != null)
                    pdesc = pdesc + "set";
                pf.Add((m.Name, GetDescTypeName(pi.PropertyType), pdesc, fdesc));
            }
            else if (m.MemberType == MemberTypes.Field)
            {
                var fi = (FieldInfo)m;
                var fdesc = GetFirstDescriptor(classname + "." + m.Name);
                pf.Add((m.Name, GetDescTypeName(fi.FieldType), string.Empty, fdesc));
            }
        }
        return pf;
    }

    static void CreateClass(Type type)
    {
        if (type.MemberType == MemberTypes.NestedType ||
            type.IsGenericType)
            return;

        var classname = GetReflectTypeName(type);
        TryNamespace(classname);

        var staticMN = GetPropertyGetSetMethod(true, type);
        var staticPF = GetPropertyAndField(true, classname, type);
        var instMN = GetPropertyGetSetMethod(false, type);
        var instPF = GetPropertyAndField(false, classname, type);

        var writer = new StringBuilder();
        var desc = GetFirstDescriptor(classname);
        DescWriteClass(writer, classname, GetDescTypeName(type.BaseType),
                desc, staticPF, instPF);

        //静态方法，属性，变量
        var members = type.GetMembers(BindingFlags.Static | BindingFlags.Public);
        foreach (var m in members)
        {
            if (m.DeclaringType != type)
                continue;
            if (m.ReflectedType.IsGenericType)
                continue;

            if (m.MemberType == MemberTypes.Method)
            {
                //函数
                if (staticMN.Contains((MethodInfo)m))
                    continue;
                WriteMethod(writer, classname, (MethodInfo)m, true);
            }
        }
        //非静态方法，属性，变量
        members = type.GetMembers(BindingFlags.Instance | BindingFlags.Public);
        foreach (var m in members)
        {
            if (m.DeclaringType != type)
                continue;

            if (m.MemberType == MemberTypes.Method)
            {
                //函数
                if (instMN.Contains((MethodInfo)m))
                    continue;
                WriteMethod(writer, classname, (MethodInfo)m, false);
            }
        }
        AddScript(classname, writer);

        //类中定义枚举
        var nestedtypes = type.GetNestedTypes(BindingFlags.Public);
        foreach (var t in nestedtypes)
        {
            if (!t.IsEnum)
                continue;
            CreateEnum(t);
        }
    }

    static void WriteMethod(StringBuilder writer, string classname, MethodInfo method, bool isStatic)
    {
        
        var parameters = method.GetParameters();
        var parampairs = new List<(ParamDescriptor, string)>();
        var returnpairs = new List<(ParamDescriptor, string)>();
        var returns = new List<string>();

        var paramnames = new List<string>();
        for (var i = 0; i < parameters.Length; ++i)
        {
            paramnames.Add(parameters[i].Name.ToLower());
        }

        var desc = GetFirstDescriptor(classname + "." + method.Name);
        var matchDesc = GetMatchDescriptor(classname + "." + method.Name, paramnames);
        var match = false;
        if (matchDesc != null)
        {
            desc = matchDesc;
            match = true;
        }

        if (desc != null)
        {
            var count = Math.Min(desc.@params.Count, parameters.Length);
            for (var i = 0; i < count; ++i)
            {
                var p = parameters[i];
                var pt = p.ParameterType;
                if (pt.IsByRef && p.IsOut)
                {
                    returnpairs.Add((desc.@params[i], GetDescTypeName(pt)));
                }
                else
                {
                    parampairs.Add((desc.@params[i], GetDescTypeName(pt)));
                }
            }
        }
        else
        {
            var count = parameters.Length;
            for (var i = 0; i < count; ++i)
            {
                var p = parameters[i];
                var pt = p.ParameterType;
                if (pt.IsByRef && p.IsOut)
                {
                    returnpairs.Add((new ParamDescriptor
                    {
                        name = p.Name,
                        summary = "",
                        summarylines = new string[0],
                    }, GetDescTypeName(pt)));
                }
                else
                {
                    parampairs.Add((new ParamDescriptor
                    {
                        name = p.Name,
                        summary = "",
                        summarylines = new string[0],
                    }, GetDescTypeName(pt)));
                }
            }

        }
        DescWriteMethod(writer, desc,
            match ? parampairs : null,
            GetDescTypeName(method.ReturnType),
            match ? returnpairs : null);

        writer.Append(string.Format(isStatic ? "function {0}.{1}(" : "function {0}:{1}(",
            classname, method.Name));

        bool flag = false;
        for (var i = 0; i < parameters.Length; ++i)
        {
            var p = parameters[i];
            var pt = p.ParameterType;

            if (pt.IsByRef && p.IsOut)
            {
                continue;
            }
            if (flag)
                writer.Append(", ");
            writer.Append(CheckLuaKeyword(p.Name));
            flag = true;
        }
        writer.AppendLine(") end");
        writer.AppendLine();
    }

    static void CreateEnum(Type type)
    {
        var classname = GetReflectTypeName(type);
        TryNamespace(classname);

        var desc = GetFirstDescriptor(classname);
        var writer = new StringBuilder();
        {
            if (desc != null)
            {
                if (desc.summarylines.Length > 1)
                {
                    foreach (var line in desc.summarylines)
                    {
                        writer.AppendLine(string.Format("--- {0}", line));
                    }
                    writer.AppendLine(string.Format("--- @class {0}", classname));
                }
                else
                {
                    writer.AppendLine(string.Format("--- @class {0} {1}", classname, desc.summary));
                }
            }
            writer.AppendLine(string.Format("{0} = {{", classname));

            var fields = type.GetFields();
            foreach (var f in fields)
            {
                if (!f.FieldType.IsEnum)
                    continue;
                var attribs = f.GetCustomAttributes(typeof(ObsoleteAttribute), true);
                if (attribs != null && attribs.Length > 0)
                    continue;

                var fdesc = GetFirstDescriptor(classname + "." + f.Name);
                if (fdesc != null)
                {
                    foreach (var line in fdesc.summarylines)
                    {
                        writer.AppendLine(string.Format("    --- {0}", line));
                    }
                }
                writer.AppendLine(string.Format("    {0} = {1},", f.Name, f.GetRawConstantValue().ToString()));
            }
            writer.AppendLine("}");
            writer.AppendLine();
        }

        AddScript(classname, writer);
    }

    static string GetDescTypeName(Type type)
    {
        if (type == typeof(Array))
        {
            return "table";
        }
        else if (type.BaseType == typeof(System.MulticastDelegate))
        {
            return "function";
        }
        else if (type.BaseType == typeof(Array))
        {
            return GetDescTypeName(type.GetElementType()) + "[]";
        }
        else if (type.GetInterface("System.Collections.IList") != null)
        {
            var args = type.GetGenericArguments();
            if (args != null && args.Length > 0)
                return GetDescTypeName(args[0]) + "[]";
            else
                return "table";
        }
        else if (type.GetInterface("System.Collections.IDictionary") != null)
        {
            var args = type.GetGenericArguments();
            var left = args[0];
            var right = args[1];
            return "table<" + GetDescTypeName(left) + ", " + GetDescTypeName(right) + ">";
        }
        else if (type.BaseType == typeof(System.Enum))
        {
            return GetReflectTypeName(type);
        }
        else if (type == typeof(int)
            || type == typeof(uint)
            || type == typeof(short)
            || type == typeof(ushort)
            || type == typeof(char)
            || type == typeof(byte)
            || type == typeof(long)
            || type == typeof(ulong)
            || type == typeof(float)
            || type == typeof(System.Int16)
            || type == typeof(System.Int32)
            || type == typeof(System.Int64)
            || type == typeof(System.Double)
            || type == typeof(System.Single))
        {
            return "number";
        }
        else if (type == typeof(bool))
        {
            return "boolean";
        }
        else if (type == typeof(string))
        {
            return "string";
        }
        else
        {
            return GetReflectTypeName(type);
        }
    }

    static string GetReflectTypeName(Type type)
    {
        string name = type.Name;
        if (type.Name.IndexOf('<') >=0)
        {
            Console.WriteLine(type.Name);
        }

        var t = type.ReflectedType;
        while (t != null)
        {
            name = t.Name + "." + name;
            t = t.ReflectedType;
        }
        if (!string.IsNullOrEmpty(type.Namespace))
            name = type.Namespace + "." + name;

        if (!string.IsNullOrEmpty(PrefixNamespace))
            name = PrefixNamespace + name;
        return name;
    }

    static void TryNamespace(string name)
    {
        var ss = name.Split('.');
        var s = "";
        for (int i = 0; i < ss.Length - 1; ++i)
        {
            s += ss[i];
            if (!namespaceSet.Contains(s))
            {
                if (AllInOne)
                {
                    typeDefines.Add(string.Format("{0} = {{}}", s));
                }
                else
                {
                    namespaceDefine.AppendLine(string.Format("{0} = {{}}", s));
                }
                namespaceSet.Add(s);
            }
            if (i < ss.Length - 2)
                s += ".";
        }
    }

    static void DescWriteClass(StringBuilder writer, string classname,
        string parentclassname, Descriptor desc,
        List<(string name, string type, string pdesc, Descriptor fdesc)> staticPF,
        List<(string name, string type, string pdesc, Descriptor fdesc)> instPF)
    {
        var descclassname = classname;
        if (!string.IsNullOrEmpty(parentclassname) &&
            string.CompareOrdinal(parentclassname, "System.Object") != 0 &&
            string.CompareOrdinal(parentclassname, "System.ValueType") != 0)
            descclassname = classname + ":" + parentclassname;

        string summary = string.Empty;
        string[] summarylines = null;
        if (desc != null)
        {
            summary = desc.summary;
            summarylines = desc.summarylines;
        }

        if (summarylines != null && summarylines.Length > 1)
        {
            foreach (var line in summarylines)
            {
                writer.AppendLine(string.Format("--- {0}", line));
            }
            writer.AppendLine(string.Format("--- @class {0}", descclassname));
        }
        else
        {
            writer.AppendLine(string.Format("--- @class {0} {1}", descclassname, summary));
        }

        foreach (var item in staticPF)
        {
            DescWriteField(writer, item.name, item.type, item.pdesc, item.fdesc);
        }
        foreach (var item in instPF)
        {
            DescWriteField(writer, item.name, item.type, item.pdesc, item.fdesc);
        }
        writer.AppendLine(string.Format("{0} = {{}}", classname));
        writer.AppendLine();
    }

    static void DescWriteField(StringBuilder writer, string name, string type, string property, Descriptor desc)
    {
        name = CheckLuaKeyword(name);
        if (desc != null)
        {
            if (string.IsNullOrEmpty(property))
            {
                if (desc.summarylines.Length > 1)
                {
                    writer.AppendLine(string.Format("--- @field {0} {1} {2}", name, type, desc.summarylines[0]));
                    for (var i = 1; i < desc.summarylines.Length; ++i)
                    {
                        writer.AppendLine(string.Format("---       {0}", desc.summarylines[i]));
                    }
                }
                else
                {
                    writer.AppendLine(string.Format("--- @field {0} {1} {2}", name, type, desc.summary));
                }
            }
            else
            {
                writer.AppendLine(string.Format("--- @field {0} {1} {2}", name, type, property));
                for (var i = 0; i < desc.summarylines.Length; ++i)
                {
                    writer.AppendLine(string.Format("---       {0}", desc.summarylines[i]));
                }
            }
        }
        else
        {
            writer.AppendLine(string.Format("--- @field {0} {1}", name, type));
        }
    }

    static void DescWriteMethod(StringBuilder writer, Descriptor desc,
        List<(ParamDescriptor, string)> @params, string returntype,
        List<(ParamDescriptor, string)> returns)
    {
        if (desc != null)
        {
            foreach (var line in desc.summarylines)
            {
                writer.AppendLine(string.Format("--- {0}", line));
            }
        }

        if (@params != null)
        {
            foreach (var pa in @params)
            {
                var p = pa.Item1;
                if (p.summarylines.Length > 1)
                {
                    writer.AppendLine(string.Format("--- @param {0} {1} {2}", 
                        CheckLuaKeyword(p.name), pa.Item2, p.summarylines[0]));
                    for (var l = 1; l < p.summarylines.Length; ++l)
                    {
                        writer.AppendLine(string.Format("---       {0}", p.summarylines[l]));
                    }
                }
                else
                {
                    writer.AppendLine(string.Format("--- @param {0} {1} {2}", 
                        CheckLuaKeyword(p.name), pa.Item2, p.summary));
                }
            }
        }

        if (returntype != "System.Void" && !string.IsNullOrEmpty(returntype))
        {
            if (desc != null)
            {
                if (desc.returnlines.Length > 1)
                {
                    writer.AppendLine(string.Format("--- @return {0} {1}", returntype, desc.returnlines[0]));
                    for (var l = 1; l < desc.returnlines.Length; ++l)
                    {
                        writer.AppendLine(string.Format("---       {0}", desc.returnlines[l]));
                    }
                }
                else
                {
                    writer.AppendLine(string.Format("--- @return {0} {1}", returntype, desc.@return));
                }
            }
            else
            {
                writer.AppendLine(string.Format("--- @return {0}", returntype));
            }
        }

        if (@returns != null)
        {
            foreach (var pa in @returns)
            {
                var p = pa.Item1;
                if (p.summarylines.Length > 1)
                {
                    writer.AppendLine(string.Format("--- @return {0} {1}", pa.Item2, p.summarylines[0]));
                    for (var l = 1; l < p.summarylines.Length; ++l)
                    {
                        writer.AppendLine(string.Format("---       {0}", p.summarylines[l]));
                    }
                }
                else
                {
                    writer.AppendLine(string.Format("--- @return {0} {1}", pa.Item2, p.summary));
                }
            }
        }
    }

    static void AddScript(string classname, StringBuilder writer)
    {
        var script = writer.ToString();
        if (string.IsNullOrEmpty(script))
            return;

        if (AllInOne)
        {
            typeDefines.Add("-------------------------------------------------------------------------------");
            typeDefines.Add(script);
        }
        else
        {
            if (!string.IsNullOrEmpty(classname))
            {
                if (fileDefines.TryGetValue(classname, out var result))
                {
                    script = result + script;
                }
                fileDefines[classname] = script;
            }
        }
    }

    static string CheckLuaKeyword(string n)
    {
        if (LuaKeyword.Contains(n))
            return "_" + n;
        else
            return n;
    }

    static HashSet<Type> existedSet = new HashSet<Type>();
    static HashSet<string> namespaceSet = new HashSet<string>();
    static List<string> typeDefines = new List<string>();

    static StringBuilder namespaceDefine = new StringBuilder();
    static Dictionary<string, string> fileDefines = new Dictionary<string, string>();
}
